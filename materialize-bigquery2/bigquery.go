package main

import (
	"context"
	"errors"
	"fmt"

	"cloud.google.com/go/bigquery"
	pf "github.com/estuary/flow/go/protocols/flow"
	"google.golang.org/api/googleapi"
)

var (
	errPrivateProjection = errors.New("projection is private and should not be included")
	errNotFound          = errors.New("not found")
)

func runJob(ctx context.Context, query *bigquery.Query) (*bigquery.Job, error) {
	job, err := query.Run(ctx)
	if err != nil {
		return nil, fmt.Errorf("run: %w", err)
	}
	status, err := job.Wait(ctx)
	if err != nil {
		if e, ok := err.(*googleapi.Error); ok && e.Code == 404 {
			return nil, errNotFound // The table wasn't found
		}
		return job, fmt.Errorf("wait: %w", err)
	}
	if err := status.Err(); err != nil {
		return job, fmt.Errorf("status: %w", err)
	}
	if !status.Done() {
		return job, fmt.Errorf("query not done")
	}

	return job, nil
}

// Because binding.Collection.Projections doesn't respect the same order as
// binding.FieldSelection.AllFields(), the schema needs to be generated by having an inner loop
// matching the projection then assigning it the index as defined in AllFields().
// If binding.Collection.Projections would honor the same ordering, this function could
// be simplified to just iterate over the projection slice and remove the need for a few
// extra error handling as defined in fieldSchemaForNameAndProjections
func schemaForBinding(binding *pf.MaterializationSpec_Binding) (bigquery.Schema, error) {
	fields := binding.FieldSelection.AllFields()
	schema := make(bigquery.Schema, len(fields))

	for idx, fieldName := range fields {
		var (
			err   error
			field *bigquery.FieldSchema
		)

		if field, err = fieldSchemaForNameAndProjections(fieldName, binding.Collection.Projections); err == errPrivateProjection {
			continue
		}

		if err != nil {
			return nil, fmt.Errorf("generating a field schema for field: %s, %w", fieldName, err)
		}

		schema[idx] = field
	}

	return schema, nil
}

func fieldSchemaForNameAndProjections(fieldName string, projections []pf.Projection) (*bigquery.FieldSchema, error) {
	var projection *pf.Projection

	for _, p := range projections {
		if p.Field == fieldName {
			projection = &p
			break
		}
	}

	if projection == nil {
		return nil, errNotFound
	}

	if projection.Inference.Exists == pf.Inference_INVALID || projection.Inference.Exists == pf.Inference_CANNOT {
		return nil, errNotFound
	}

	return &bigquery.FieldSchema{
		Name:        projection.Field,
		Type:        preferredFieldType(projection.Inference.Types),
		Required:    projection.Inference.Exists == pf.Inference_MUST,
		Description: projection.Inference.Description,
	}, nil
}

func preferredFieldType(possibleFields []string) bigquery.FieldType {
	switch possibleFields[0] {
	case "string":
		return bigquery.StringFieldType
	case "integer":
		return bigquery.IntegerFieldType
	default:
		return bigquery.StringFieldType
	}
}

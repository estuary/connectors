--- Begin `a-schema`.key_value createTargetTable ---

CREATE TABLE IF NOT EXISTS `a-schema`.key_value (
  key1 BIGINT NOT NULL COMMENT 'auto-generated projection of JSON at: /key1 with inferred types: [integer]',
  key2 BOOLEAN NOT NULL COMMENT 'auto-generated projection of JSON at: /key2 with inferred types: [boolean]',
  `key!binary` BINARY NOT NULL COMMENT 'auto-generated projection of JSON at: /key!binary with inferred types: [string]',
  array STRING COMMENT 'auto-generated projection of JSON at: /array with inferred types: [array]',
  binary BINARY COMMENT 'auto-generated projection of JSON at: /binary with inferred types: [string]',
  boolean BOOLEAN COMMENT 'auto-generated projection of JSON at: /boolean with inferred types: [boolean]',
  flow_published_at TIMESTAMP NOT NULL COMMENT 'Flow Publication Time
Flow publication date-time of this document
auto-generated projection of JSON at: /_meta/uuid with inferred types: [string]',
  integer BIGINT COMMENT 'auto-generated projection of JSON at: /integer with inferred types: [integer]',
  multiple STRING COMMENT 'auto-generated projection of JSON at: /multiple with inferred types: [boolean integer object]',
  number DOUBLE COMMENT 'auto-generated projection of JSON at: /number with inferred types: [number]',
  object STRING COMMENT 'auto-generated projection of JSON at: /object with inferred types: [object]',
  string STRING COMMENT 'auto-generated projection of JSON at: /string with inferred types: [string]',
  `stringInteger` BIGINT COMMENT 'auto-generated projection of JSON at: /stringInteger with inferred types: [integer string]',
  `stringNumber` DOUBLE COMMENT 'auto-generated projection of JSON at: /stringNumber with inferred types: [number string]',
  flow_document STRING NOT NULL COMMENT 'auto-generated projection of JSON at:  with inferred types: [object]'
) COMMENT 'Generated for materialization test/sqlite of collection key/value';
--- End `a-schema`.key_value createTargetTable ---

--- Begin `a-schema`.delta_updates createTargetTable ---

CREATE TABLE IF NOT EXISTS `a-schema`.delta_updates (
  `theKey` STRING NOT NULL COMMENT 'auto-generated projection of JSON at: /theKey with inferred types: [string]',
  `aValue` BIGINT COMMENT 'A super-awesome value.
auto-generated projection of JSON at: /aValue with inferred types: [integer]',
  flow_published_at TIMESTAMP NOT NULL COMMENT 'Flow Publication Time
Flow publication date-time of this document
auto-generated projection of JSON at: /_meta/uuid with inferred types: [string]'
) COMMENT 'Generated for materialization test/sqlite of collection delta/updates';
--- End `a-schema`.delta_updates createTargetTable ---

--- Begin alter table add columns ---

ALTER TABLE `a-schema`.key_value ADD COLUMN
	first_new_column STRING,
	second_new_column BOOL;
--- End alter table add columns ---

--- Begin `a-schema`.key_value loadQuery ---
SELECT 0, `a-schema`.key_value.flow_document
	FROM `a-schema`.key_value
	JOIN (
		(
			SELECT
			key1, key2, `key!binary`
			FROM json.`file1`
		)
		 UNION ALL (
			SELECT
			key1, key2, `key!binary`
			FROM json.`file2`
		)
	) AS r
	ON `a-schema`.key_value.key1 = r.key1 AND `a-schema`.key_value.key2 = r.key2 AND `a-schema`.key_value.`key!binary` = unbase64(r.`key!binary`)
--- End `a-schema`.key_value loadQuery ---

--- Begin `a-schema`.key_value mergeInto ---
	MERGE INTO `a-schema`.key_value AS l
	USING (
		(
			SELECT
			key1::BIGINT, key2::BOOLEAN, unbase64(`key!binary`)::BINARY as `key!binary`, array::STRING, unbase64(binary)::BINARY as binary, boolean::BOOLEAN, flow_published_at::TIMESTAMP, integer::BIGINT, multiple::STRING, number::DOUBLE, object::STRING, string::STRING, `stringInteger`::BIGINT, `stringNumber`::DOUBLE, flow_document::STRING
			FROM json.`file1`
		)
		 UNION ALL (
			SELECT
			key1::BIGINT, key2::BOOLEAN, unbase64(`key!binary`)::BINARY as `key!binary`, array::STRING, unbase64(binary)::BINARY as binary, boolean::BOOLEAN, flow_published_at::TIMESTAMP, integer::BIGINT, multiple::STRING, number::DOUBLE, object::STRING, string::STRING, `stringInteger`::BIGINT, `stringNumber`::DOUBLE, flow_document::STRING
			FROM json.`file2`
		)
	) AS r
	ON l.key1 = r.key1 AND l.key2 = r.key2 AND l.`key!binary` = r.`key!binary`
	WHEN MATCHED AND r.flow_document='"delete"' THEN
		DELETE
	WHEN MATCHED THEN
		UPDATE SET l.array = r.array, l.binary = r.binary, l.boolean = r.boolean, l.flow_published_at = r.flow_published_at, l.integer = r.integer, l.multiple = r.multiple, l.number = r.number, l.object = r.object, l.string = r.string, l.`stringInteger` = r.`stringInteger`, l.`stringNumber` = r.`stringNumber`, l.flow_document = r.flow_document
	WHEN NOT MATCHED THEN
		INSERT (key1, key2, `key!binary`, array, binary, boolean, flow_published_at, integer, multiple, number, object, string, `stringInteger`, `stringNumber`, flow_document)
		VALUES (r.key1, r.key2, r.`key!binary`, r.array, r.binary, r.boolean, r.flow_published_at, r.integer, r.multiple, r.number, r.object, r.string, r.`stringInteger`, r.`stringNumber`, r.flow_document);
--- End `a-schema`.key_value mergeInto ---

--- Begin `a-schema`.key_value copyIntoDirect ---
	COPY INTO `a-schema`.key_value FROM (
    SELECT
		key1::BIGINT, key2::BOOLEAN, unbase64(`key!binary`)::BINARY as `key!binary`, array::STRING, unbase64(binary)::BINARY as binary, boolean::BOOLEAN, flow_published_at::TIMESTAMP, integer::BIGINT, multiple::STRING, number::DOUBLE, object::STRING, string::STRING, `stringInteger`::BIGINT, `stringNumber`::DOUBLE, flow_document::STRING
  FROM 'test-staging-path'
	)
  FILEFORMAT = JSON
  FILES = ('file1','file2')
  FORMAT_OPTIONS ( 'mode' = 'FAILFAST', 'ignoreMissingFiles' = 'false' )
	COPY_OPTIONS ( 'mergeSchema' = 'true' )
  ;
--- End `a-schema`.key_value copyIntoDirect ---

--- Begin `a-schema`.delta_updates loadQuery ---
SELECT -1, ""
--- End `a-schema`.delta_updates loadQuery ---

--- Begin `a-schema`.delta_updates mergeInto ---
	MERGE INTO `a-schema`.delta_updates AS l
	USING (
		(
			SELECT
			`theKey`::STRING, `aValue`::BIGINT, flow_published_at::TIMESTAMP
			FROM json.`file1`
		)
		 UNION ALL (
			SELECT
			`theKey`::STRING, `aValue`::BIGINT, flow_published_at::TIMESTAMP
			FROM json.`file2`
		)
	) AS r
	ON l.`theKey` = r.`theKey`
	WHEN MATCHED THEN
		UPDATE SET l.`aValue` = r.`aValue`, l.flow_published_at = r.flow_published_at
	WHEN NOT MATCHED THEN
		INSERT (`theKey`, `aValue`, flow_published_at)
		VALUES (r.`theKey`, r.`aValue`, r.flow_published_at);
--- End `a-schema`.delta_updates mergeInto ---

--- Begin `a-schema`.delta_updates copyIntoDirect ---
	COPY INTO `a-schema`.delta_updates FROM (
    SELECT
		`theKey`::STRING, `aValue`::BIGINT, flow_published_at::TIMESTAMP
  FROM 'test-staging-path'
	)
  FILEFORMAT = JSON
  FILES = ('file1','file2')
  FORMAT_OPTIONS ( 'mode' = 'FAILFAST', 'ignoreMissingFiles' = 'false' )
	COPY_OPTIONS ( 'mergeSchema' = 'true' )
  ;
--- End `a-schema`.delta_updates copyIntoDirect ---



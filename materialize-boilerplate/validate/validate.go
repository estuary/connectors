package validate

import (
	"encoding/json"
	"fmt"
	"slices"

	pf "github.com/estuary/flow/go/protocols/flow"
	pm "github.com/estuary/flow/go/protocols/materialize"
)

// Constrainter represents the endpoint requirements for validating new projections or changes to
// existing projections.
type Constrainter interface {
	// NewConstraints produces constraints for a projection that is not part of the current
	// materialization.
	NewConstraints(p *pf.Projection, deltaUpdates bool) *pm.Response_Validated_Constraint

	// Compatible reports whether two projections are compatible. Generally this would mean they are
	// the same non-null JSON types(s), but can be more forgiving for endpoints that do not impose
	// strict requirements on the structure of materialized fields.
	Compatible(existing *pf.Projection, proposed *pf.Projection, rawFieldConfig json.RawMessage) (bool, error)

	// DescriptionForType produces a human-readable description for a type, which is used in
	// constraint descriptions when there is an incompatible type change.
	DescriptionForType(p *pf.Projection) string
}

// Validator performs validation of a materialization binding.
type Validator struct {
	c Constrainter
}

func NewValidator(c Constrainter) Validator {
	return Validator{
		c: c,
	}
}

// ValidateSelectedFields validates that the field selection of a binding are compatible with its
// own constraints. If any constraints would be violated, an error is returned with the reason why.
func (v Validator) ValidateSelectedFields(
	binding *pf.MaterializationSpec_Binding,
	storedSpec *pf.MaterializationSpec,
) error {
	// Track all the location pointers for each included field so that we can verify all the
	// LOCATION_REQUIRED constraints are met.
	includedPointers := make(map[string]bool)

	// For standard updates materializations, only a single projection if the root document is
	// allowed in the field selection.
	rootDocFields := 0

	// Calculated constraints for the fields of this binding.
	bindingConstraints, err := v.ValidateBinding(
		binding.ResourcePath,
		binding.DeltaUpdates,
		binding.Backfill,
		binding.Collection,
		binding.FieldSelection.FieldConfigJsonMap,
		storedSpec,
	)
	if err != nil {
		return err
	}

	// Does each field in the materialization have an allowable constraint?
	allFields := binding.FieldSelection.AllFields()
	for _, field := range allFields {
		var projection = binding.Collection.GetProjection(field)
		if projection == nil {
			return fmt.Errorf("no such projection for field '%s'", field)
		}
		if projection.IsRootDocumentProjection() {
			rootDocFields += 1
			if !binding.DeltaUpdates && rootDocFields > 1 {
				return fmt.Errorf("only a single root document projection can be included in the field selection for a standard updates materialization")
			}
		}
		includedPointers[projection.Ptr] = true
		constraint := bindingConstraints[field]
		if bindingConstraints[field].Type.IsForbidden() {
			return fmt.Errorf("the field '%s' may not be materialized because it has constraint: %s with reason: %s", field, constraint.Type, constraint.Reason)
		}
	}

	checkRequired := func(field string, constraint *pm.Response_Validated_Constraint) error {
		switch constraint.Type {
		case pm.Response_Validated_Constraint_FIELD_REQUIRED:
			if !slices.Contains(allFields, field) {
				return fmt.Errorf("required field '%s' is missing. It is required because: %s", field, constraint.Reason)
			}
		case pm.Response_Validated_Constraint_LOCATION_REQUIRED:
			var projection = binding.Collection.GetProjection(field)
			if !includedPointers[projection.Ptr] {
				return fmt.Errorf(
					"the materialization must include a projection of location %s, but no such projection is included. It is required because: %s",
					projection.Ptr,
					constraint.Reason,
				)
			}
		}

		return nil
	}

	// Are all of the required fields and locations included? This is based on both the constraints
	// generated by the (possible) change to an existing binding and the constraints for the binding
	// as if it were being applied new, to account for existing selected fields of the binding
	// always being "recommended", which may shadow their "required" constraints that were
	// originally calculated.
	for field, constraint := range bindingConstraints {
		if err := checkRequired(field, constraint); err != nil {
			return err
		}
	}
	for field, constraint := range v.validateNewBinding(binding.Collection, binding.DeltaUpdates) {
		if err := checkRequired(field, constraint); err != nil {
			return err
		}
	}

	return err
}

// ValidateBinding calculates the constraints for a new binding or a change to an existing binding.
func (v Validator) ValidateBinding(
	path []string,
	deltaUpdates bool,
	backfill uint32,
	boundCollection pf.CollectionSpec,
	fieldConfigJsonMap map[string]json.RawMessage,
	storedSpec *pf.MaterializationSpec,
) (map[string]*pm.Response_Validated_Constraint, error) {
	existingBinding, err := FindExistingBinding(path, boundCollection.Name, storedSpec)
	if err != nil {
		return nil, err
	}

	if existingBinding != nil && existingBinding.Backfill > backfill {
		// Sanity check: Don't allow backfill counters to decrease.
		return nil, fmt.Errorf(
			"backfill count %d for proposed binding of collection %s is less than previously applied count of %d",
			backfill,
			existingBinding.Collection.Name.String(),
			existingBinding.Backfill,
		)
	}

	var constraints map[string]*pm.Response_Validated_Constraint
	if existingBinding == nil || backfill != existingBinding.Backfill {
		constraints = v.validateNewBinding(boundCollection, deltaUpdates)
	} else {
		if existingBinding.DeltaUpdates && !deltaUpdates {
			// We allow a binding to switch from standard => delta updates but not the other
			// way. This is because a standard materialization is trivially a valid
			// delta-updates materialization.
			return nil, fmt.Errorf("changing binding of collection %s from delta updates to standard updates is not allowed", existingBinding.Collection.Name.String())
		}
		constraints, err = v.validateMatchesExistingBinding(existingBinding, boundCollection, deltaUpdates, fieldConfigJsonMap)
		if err != nil {
			return nil, err
		}
	}

	return constraints, nil
}

func (v Validator) validateNewBinding(boundCollection pf.CollectionSpec, deltaUpdates bool) map[string]*pm.Response_Validated_Constraint {
	constraints := make(map[string]*pm.Response_Validated_Constraint)
	for _, projection := range boundCollection.Projections {
		constraints[projection.Field] = v.c.NewConstraints(&projection, deltaUpdates)
	}
	return constraints
}

func (v Validator) validateMatchesExistingBinding(
	existing *pf.MaterializationSpec_Binding,
	boundCollection pf.CollectionSpec,
	deltaUpdates bool,
	fieldConfigJsonMap map[string]json.RawMessage,
) (map[string]*pm.Response_Validated_Constraint, error) {
	constraints := make(map[string]*pm.Response_Validated_Constraint)

	for _, field := range append(existing.FieldSelection.Keys, existing.FieldSelection.Values...) {
		constraint := new(pm.Response_Validated_Constraint)

		existingProjection := existing.Collection.GetProjection(field)
		proposedProjection := boundCollection.GetProjection(field)

		if proposedProjection == nil {
			// A value field has been removed, so no constraint is needed. Key fields cannot be
			// removed from an established collection.
			continue
		}

		// Is the proposed type completely disallowed by the materialization? This differs from
		// being UNSATISFIABLE, which implies that re-creating the materialization could resolve the
		// difference.
		if c := v.c.NewConstraints(proposedProjection, deltaUpdates); c.Type == pm.Response_Validated_Constraint_FIELD_FORBIDDEN {
			constraints[field] = c
			continue
		}

		// We match on the endpoint-specific type here and not just the JSON type to account for
		// incompatible changes to string format fields, such as removing a numeric format. This
		// would imply that the field is no longer a numeric value, which would be incompatible with
		// the materialized mapping and should trigger an evolution of the materialization.
		if compatible, err := v.c.Compatible(existingProjection, proposedProjection, fieldConfigJsonMap[field]); err != nil {
			return nil, fmt.Errorf("validating binding for collection '%s': %w", boundCollection.Name.String(), err)
		} else if compatible {
			if existingProjection.IsPrimaryKey {
				constraint.Type = pm.Response_Validated_Constraint_FIELD_REQUIRED
				constraint.Reason = "This field is a key in the current materialization"
			} else {
				// TODO(whb): Really this should be "FIELD_RECOMMENDED", but that is not a
				// constraint that has been implemented currently. This would be an issue if there
				// are multiple projections of the same location.
				constraint.Type = pm.Response_Validated_Constraint_LOCATION_RECOMMENDED
				constraint.Reason = "This location is part of the current materialization"
			}
		} else {
			constraint.Type = pm.Response_Validated_Constraint_UNSATISFIABLE
			constraint.Reason = fmt.Sprintf(
				"Field '%s' is already being materialized as type '%s' and cannot be changed to type '%s'",
				field,
				v.c.DescriptionForType(existingProjection),
				v.c.DescriptionForType(proposedProjection),
			)
		}

		constraints[field] = constraint
	}

	docFields := []string{}
	for _, p := range boundCollection.Projections {
		if !deltaUpdates && p.IsRootDocumentProjection() {
			docFields = append(docFields, p.Field)
			// Only the originally selected root document projection is allowed to be selected for
			// changes to a standard updates materialization.
			if p.Field == existing.FieldSelection.Document {
				constraints[p.Field] = &pm.Response_Validated_Constraint{
					Type:   pm.Response_Validated_Constraint_FIELD_REQUIRED,
					Reason: "This field is the document in the current materialization",
				}
			} else {
				constraints[p.Field] = &pm.Response_Validated_Constraint{
					Type: pm.Response_Validated_Constraint_FIELD_FORBIDDEN,
					Reason: fmt.Sprintf(
						"Cannot materialize root document projection '%s' because field '%s' is already being materialized as the document",
						p.Field,
						existing.FieldSelection.Document,
					),
				}
			}
		}

		// Build constraints for new projections of the binding.
		if _, ok := constraints[p.Field]; !ok {
			constraints[p.Field] = v.c.NewConstraints(&p, deltaUpdates)
		}
	}

	if !deltaUpdates && !slices.Contains(docFields, existing.FieldSelection.Document) {
		// For standard updates, the proposed binding must still have the original document field.
		// If it doesn't, make sure to fail the build with a constraint on a root document
		// projection that it does have.
		constraints[docFields[0]] = &pm.Response_Validated_Constraint{
			Type: pm.Response_Validated_Constraint_UNSATISFIABLE,
			Reason: fmt.Sprintf(
				"The root document must be materialized as field '%s'",
				existing.FieldSelection.Document,
			),
		}
	}

	return constraints, nil
}

// FindExistingBinding locates a binding within an existing stored specification, and verifies that
// there are no target path conflicts with a proposed binding that does not already exist.
func FindExistingBinding(
	resourcePath []string,
	proposedCollection pf.Collection,
	storedSpec *pf.MaterializationSpec,
) (*pf.MaterializationSpec_Binding, error) {
	if storedSpec == nil {
		return nil, nil // Binding is trivially not found
	}
	for _, existingBinding := range storedSpec.Bindings {
		if existingBinding.Collection.Name == proposedCollection && slices.Equal(resourcePath, existingBinding.ResourcePath) {
			// The binding already exists for this collection and is being materialized to the
			// target.
			return existingBinding, nil
		} else if slices.Equal(resourcePath, existingBinding.ResourcePath) {
			// There is a binding already materializing to the target, but for a different
			// collection.
			return nil, fmt.Errorf(
				"cannot add a new binding to materialize collection '%s' to '%s' because an existing binding for collection '%s' is already materializing to '%s'",
				proposedCollection.String(),
				resourcePath,
				existingBinding.Collection.Name,
				resourcePath,
			)
		}
	}
	return nil, nil
}

type StringWithNumericFormat string

const (
	StringFormatInteger StringWithNumericFormat = "stringFormatInteger"
	StringFormatNumber  StringWithNumericFormat = "stringFormatNumber"
)

func AsFormattedNumeric(projection *pf.Projection) (StringWithNumericFormat, bool) {
	typesMatch := func(actual, allowed []string) bool {
		for _, t := range actual {
			if !slices.Contains(allowed, t) {
				return false
			}
		}
		return true
	}

	if !projection.IsPrimaryKey && projection.Inference.String_ != nil {
		switch {
		case projection.Inference.String_.Format == "integer" && typesMatch(projection.Inference.Types, []string{"integer", "null", "string"}):
			return StringFormatInteger, true
		case projection.Inference.String_.Format == "number" && typesMatch(projection.Inference.Types, []string{"null", "number", "string"}):
			return StringFormatNumber, true
		default:
			// Fallthrough.
		}
	}

	// Not a formatted numeric field.
	return "", false
}
